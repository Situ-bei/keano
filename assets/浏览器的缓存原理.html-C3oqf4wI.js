import{_ as a,c as r,e as i,d as s,b as l,o as t,r as c}from"./app-eRKk0_Tz.js";const n="/assets/1-1-KSI0HFsc.jpeg",d="/assets/1-2-C8dLPAmO.jpeg",p="/assets/1-1-KSI0HFsc.jpeg",h={};function g(f,e){const o=c("MarkMap");return t(),r("div",null,[e[0]||(e[0]=i('<h1 id="浏览器的缓存机制和原理" tabindex="-1"><a class="header-anchor" href="#浏览器的缓存机制和原理"><span>浏览器的缓存机制和原理</span></a></h1><h1 id="浏览器的缓存机制和原理-1" tabindex="-1"><a class="header-anchor" href="#浏览器的缓存机制和原理-1"><span>浏览器的缓存机制和原理</span></a></h1><p>浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的。</p><p>在前端开发中，我们追求性能和用户体验。对于一个网站，查看性能最简单的方式就是打开网站的速度。</p><p>而一个好的缓存策略可以大大提升网站的性能，使得已经下载后的资源被重复利用，减少客户端和服务器之间的请求次数，减少带宽，减少网络负荷。缓存可以说是性能优化中简单高效的一种优化方式了。</p><p>对于一个数据请求来说，可以分为发起<strong>网络请求</strong>、<strong>后端处理</strong>、<strong>浏览器响应</strong>三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p>',6)),s(" more "),l(o,{id:"markmap-19",content:"eJx1kE1LAlEUhvfzKw60KfAOjbWSaGMGga76BdN4bS7q3OHOZB+riFADP6IQTQRpZRunTUqJ1p/x3tFVf6HrxwiRLc97znmf9xyEkJLVWTqr2xEFwKAZyg4Zxlc4jnM4E4GwMhtRNkD0qpNOkT+9+M1bf/jIuw3RGvBinz+UeKXt3+fl0Abw4WDRVBQEsQubMOxsmq5rg6Zub4FEACCYXjcnX4WgD7xbF15v4n36I0/U+9P6W0hUOtI74NyJWlG02iFfut98iMbr+L3MC3n/2ZOUqG6YGEWp5TKambM0VZOoeZxyldfyy0QI4rrjogRNkhTBSdg7YftwlFoJ6JhYBoZ/4/7e/hv6e1haG1vqa4PHXP0U5PuApJClWxQldNcM6MEFC6/xqCwxckdTwcEsRww4pyyNmZTCKiRwlrJLMGafkMqOCgfESa/qXRXsM8dc1soPsEXkTQ=="}),e[1]||(e[1]=i('<h2 id="缓存过程分析" tabindex="-1"><a class="header-anchor" href="#缓存过程分析"><span><strong>缓存过程分析</strong></span></a></h2><p>浏览器与服务器通信的方式为应答模式。</p><p>即：浏览器发起HTTP请求———服务器响应该请求。浏览器第一次向服务器发起该请求，拿到请求结果后，会根据响应报文中响应头的缓存标识，决定是否缓存结果，缓存，则将请求结果和缓存标识存入浏览器缓存中。</p><figure><img src="'+n+'" alt="第一次发起http请求" tabindex="0" loading="lazy"><figcaption>第一次发起http请求</figcaption></figure><div class="hint-container important"><p class="hint-container-title">由此可知，浏览器的缓存机制是：</p><ol><li>浏览器<strong>每次</strong>发起请求，都会先在浏览器缓存中查找该请求<strong>结果</strong>以及<strong>缓存标识</strong>。</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入<strong>浏览器缓存中</strong>。</li></ol></div><p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 <code>HTTP Header</code> 来实现的。</p><p>当存在缓存时，客户端第一次向服务器请求数据时，客户端会缓存到内存或者硬盘当中，当第二次获取相同的资源，强缓存和协商缓存的应对方式有所不同。</p><p><strong>强缓存</strong>：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从 <strong>内存/硬盘</strong> 中读取。</p><p><strong>协商缓存</strong>：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求 <strong>&quot;询问&quot;</strong> 该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取。</p><h2 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存"><span><strong>强缓存</strong></span></a></h2><p>强缓存就是向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</p><p>强缓存不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示from disk cache 或 from memory cache。</p><p>强缓存可以通过设置两种 HTTP Header 实现：<strong><code>Expires</code></strong> 和 <strong><code>Cache-Control</code></strong>。</p><ul><li>强缓存的情况主要有以下三种： <ol><li>不存在该缓存结果和缓存标识，强缓存失效，则直接向服务器发起请求(跟第一次发起请求一致)</li><li>存在该缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存</li><li>存在该缓存结果和缓存标识，且该结果没有还没有失效，强缓存生效，直接返回该结果</li></ol></li></ul><p>当浏览器向服务器发送请求的时候，服务器会将缓存规则放入 <strong>HTTP响应报文</strong> 的<strong>HTTP头</strong>中和请求结果一起返回给浏览器，控制强缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 <code>Cache-Conctrol</code> 的优先级比<code>Expires</code>高。</p><h3 id="_1-expires" tabindex="-1"><a class="header-anchor" href="#_1-expires"><span>1. Expires</span></a></h3><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。</p><p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。例如：Expires:Wed,22Oct201808:41:00GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。</p><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><p>到了HTTP/1.1，Expires已经被Cache-Control替代。</p><p>原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。</p><h3 id="_2-cache-control" tabindex="-1"><a class="header-anchor" href="#_2-cache-control"><span>2.Cache-Control</span></a></h3><p>在HTTP/1.1中，<code>Cache-Control</code>是最重要的规则，主要用于控制网页缓存。比如当 <code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p><code>Cache-Control</code> 可以在请求头或者响应头中设置，并且可以组合使用多种指令，主要取值为：</p><div class="hint-container info"><p class="hint-container-title">HTTP 缓存指令</p><ul><li><p><strong>public</strong>：所有内容都将被缓存（客户端和代理服务器都可缓存）。</p><ul><li>具体来说响应可被任何中间节点缓存，如 Browser &lt;-- proxy1 &lt;-- proxy2 &lt;-- Server，中间的proxy也可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</li></ul></li><li><p><strong>private</strong>：所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认取值。</p><ul><li>具体来说，表示中间节点不允许缓存，对于Browser &lt;-- proxy1 &lt;-- proxy2 &lt;-- Server，proxy 会老老实实把Server 返回的数据发送给Browser ,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</li></ul></li><li><p><strong>no-cache</strong>：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 <code>Cache-Control</code>的缓存控制方式做前置验证，而是使用 <code>Etag</code> 或者<code>Last-Modified</code>字段来控制缓存。注意：<code>no-cache</code>这个名字有一点误导。设置了<code>no-cache</code>之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p></li><li><p><strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p><strong>max-age</strong>：<code>max-age=xxx (xxx is numeric)</code>表示缓存内容将在xxx秒后失效</p></li><li><p><strong>s-maxage（单位为s)</strong>：同<code>max-age</code>作用一样，只在代理服务器中生效（比如CDN缓存）。</p><ul><li>比如当<code>s-maxage=60</code>时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。<code>max-age</code>用于普通缓存，而<code>s-maxage</code>用于代理缓存。<code>s-maxage</code>的优先级高于<code>max-age</code>。如果存在<code>s-maxage</code>，则会覆盖掉<code>max-age</code>和<code>Expires header</code>。</li></ul></li><li><p><strong>max-stale</strong>：能容忍的最大过期时间。<code>max-stale</code>指令标示了客户端愿意接收一个已经过期了的响应。如果指定了<code>max-stale</code>的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p></li><li><p><strong>min-fresh</strong>：能够容忍的最小新鲜度。<code>min-fresh</code>标示了客户端不愿意接受新鲜度不多于当前的age加上<code>min-fresh</code>设定的时间之和的响应。</p></li></ul></div><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span><strong>协商缓存</strong></span></a></h2><p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ol><li>协商缓存生效，返回304和Not Modified：</li></ol><figure><img src="'+d+'" alt="协商缓存生效" tabindex="0" loading="lazy"><figcaption>协商缓存生效</figcaption></figure><ol start="2"><li>协商缓存失效，返回200和请求结果(OK)：</li></ol><figure><img src="'+p+'" alt="协商缓存失效" tabindex="0" loading="lazy"><figcaption>协商缓存失效</figcaption></figure><p>缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Last-Modified</code> 和 <code>ETag</code> 。下面详细介绍这两种头部：</p><h3 id="_1-last-modified-和-if-modified-since" tabindex="-1"><a class="header-anchor" href="#_1-last-modified-和-if-modified-since"><span>1. <strong>Last-Modified 和 If-Modified-Since</strong></span></a></h3><h4 id="last-modified" tabindex="-1"><a class="header-anchor" href="#last-modified"><span>Last-Modified：</span></a></h4><ol><li>浏览器在第一次访问资源的情况下，服务器会在返回资源的同时，在response header中添加Last-Modified的header</li><li>header的值是这个资源在服务器上的最后修改时间</li><li>浏览器接收后，缓存这个文件和header。</li></ol><h4 id="if-modified-since" tabindex="-1"><a class="header-anchor" href="#if-modified-since"><span>If-Modified-Since：</span></a></h4><ol><li>浏览器下一次请求这个资源，浏览器检测到有 <code>Last-Modified</code>这个header，于是浏览器添加<code>If-Modified-Since</code>这个header，值就是Last-Modified中的值。</li><li>服务器再次收到这个资源请求，会根据 <code>If-Modified-Since</code> 中的值与服务器中这个资源的最后修改时间对比。 如果没有变化，返回304和空的响应体，直接从缓存读取。如果<code>If-Modified-Since</code>的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</li></ol><p>但是 Last-Modified 也存在一些弊端：</p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和 If-None-Match来解决这个问题</p><h3 id="_2-etag和if-none-match" tabindex="-1"><a class="header-anchor" href="#_2-etag和if-none-match"><span>2. <strong>ETag和If-None-Match</strong></span></a></h3><p>直接根据文件内容是否修改来决定缓存策略。</p><p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</p><blockquote><p>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的<code>If-None-Match</code>里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</p></blockquote><ul><li>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端。</li><li>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</li></ul><h3 id="_3-比较" tabindex="-1"><a class="header-anchor" href="#_3-比较"><span>3. <strong>比较</strong></span></a></h3><ul><li>在精确度上，Etag要优于Last-Modified。 <ul><li>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li></ul></li><li>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li><li>在优先级上，服务器校验优先考虑Etag</li></ul><h2 id="两种缓存策略的执行机制" tabindex="-1"><a class="header-anchor" href="#两种缓存策略的执行机制"><span><strong>两种缓存策略的执行机制</strong></span></a></h2><ul><li><p><strong>强制缓存优先于协商缓存进行</strong>。</p><ul><li>若强制缓存(Expires和Cache-Control)生效则直接使用缓存，</li><li>若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)。</li></ul></li><li><p><strong>协商缓存由服务器决定是否使用缓存</strong>，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p></li></ul><h2 id="缓存位置" tabindex="-1"><a class="header-anchor" href="#缓存位置"><span><strong>缓存位置</strong></span></a></h2><p>从缓存位置上来说分为4种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ol><h3 id="_1-service-worker" tabindex="-1"><a class="header-anchor" href="#_1-service-worker"><span><strong>1. Service Worker</strong></span></a></h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</p><p>使用Service Worker 的话，必须使用HTTPS协议来保障安全。Service Worker的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存那些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><p>Service Worker 实现缓存一般分为三个步骤：</p><blockquote><ol><li>注册Service Worker</li><li>监听到install事件以后就可以缓存需要的文件</li><li>在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存直接读取文件，否则就去请求数据</li></ol></blockquote><p>当Service Worker 没有命中缓存的时候，我们需要调用fetch()函数获取数据。也就是说：如果我们没有在Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。</p><p>但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h3 id="_2-memory-cache" tabindex="-1"><a class="header-anchor" href="#_2-memory-cache"><span><strong>2. Memory Cache</strong></span></a></h3><p>Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。</p><p>读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭Tab页面，内存中的缓存也就被释放。</p><p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p><p>当我们访问过页面以后，再次刷新页面，此时很多数据都来自于内存缓存。</p><p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如 &lt;linkrel=“prefetch”&gt;）下载的资源。preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p><div class="hint-container warning"><p class="hint-container-title">注意：</p><p>内存缓存在缓存资源时并不关心返回资源的HTTP缓存头<code>Cache-Contro</code>l是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对<code>Content-Type``，CORS</code> 等其他特征做校验。</p></div><h3 id="_3-disk-cache" tabindex="-1"><a class="header-anchor" href="#_3-disk-cache"><span><strong>3. Disk Cache</strong></span></a></h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比 Memory Cache 胜在容量和存储时效性上。</p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？这个问题很多人观点不一样，不过相对更合理的观点是：</p><ol><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li><li>当前系统内存使用率高的话，文件优先存储进硬盘</li></ol><h3 id="_4-push-cache" tabindex="-1"><a class="header-anchor" href="#_4-push-cache"><span><strong>4. Push Cache</strong></span></a></h3><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。</p><p>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><p>为了性能上的考虑，大部分的接口都应该选择好缓存策略，也就是我们刚刚介绍的强缓存和协商缓存策略 用户行为对缓存的影响</p><h2 id="用户行为对浏览器缓存的影响" tabindex="-1"><a class="header-anchor" href="#用户行为对浏览器缓存的影响"><span><strong>用户行为对浏览器缓存的影响</strong></span></a></h2><p>指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ol><li><p><strong>打开网页</strong>，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</p></li><li><p><strong>普通刷新 (F5)</strong>：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</p></li><li><p><strong>强制刷新 (Ctrl + F5)</strong>：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。</p></li></ol>',79))])}const x=a(h,[["render",g],["__file","浏览器的缓存原理.html.vue"]]),u=JSON.parse('{"path":"/study/coding/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.html","title":"浏览器的缓存机制和原理","lang":"zh-CN","frontmatter":{"date":"2024-10-19T00:00:00.000Z","title":"浏览器的缓存机制和原理","category":["前端","浏览器原理"],"tag":["浏览器原理","游览器缓存","面试"],"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"缓存过程分析","slug":"缓存过程分析","link":"#缓存过程分析","children":[]},{"level":2,"title":"强缓存","slug":"强缓存","link":"#强缓存","children":[{"level":3,"title":"1. Expires","slug":"_1-expires","link":"#_1-expires","children":[]},{"level":3,"title":"2.Cache-Control","slug":"_2-cache-control","link":"#_2-cache-control","children":[]}]},{"level":2,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[{"level":3,"title":"1. Last-Modified 和 If-Modified-Since","slug":"_1-last-modified-和-if-modified-since","link":"#_1-last-modified-和-if-modified-since","children":[]},{"level":3,"title":"2. ETag和If-None-Match","slug":"_2-etag和if-none-match","link":"#_2-etag和if-none-match","children":[]},{"level":3,"title":"3. 比较","slug":"_3-比较","link":"#_3-比较","children":[]}]},{"level":2,"title":"两种缓存策略的执行机制","slug":"两种缓存策略的执行机制","link":"#两种缓存策略的执行机制","children":[]},{"level":2,"title":"缓存位置","slug":"缓存位置","link":"#缓存位置","children":[{"level":3,"title":"1. Service Worker","slug":"_1-service-worker","link":"#_1-service-worker","children":[]},{"level":3,"title":"2. Memory Cache","slug":"_2-memory-cache","link":"#_2-memory-cache","children":[]},{"level":3,"title":"3. Disk Cache","slug":"_3-disk-cache","link":"#_3-disk-cache","children":[]},{"level":3,"title":"4. Push Cache","slug":"_4-push-cache","link":"#_4-push-cache","children":[]}]},{"level":2,"title":"用户行为对浏览器缓存的影响","slug":"用户行为对浏览器缓存的影响","link":"#用户行为对浏览器缓存的影响","children":[]}],"git":{"createdTime":1729368407000,"updatedTime":1729368407000,"contributors":[{"name":"situ-bei","email":"2606405907@qq.com","commits":1}]},"readingTime":{"minutes":15.43,"words":4630},"filePathRelative":"study/coding/interview/浏览器的缓存原理.md","localizedDate":"2024年10月19日"}');export{x as comp,u as data};

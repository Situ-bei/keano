---
number headings: auto, first-level 1, max 6, contents ^top, 1.1
title: 《ES 基础概念》
category:
- 前端
- JS
tags:
- JS
- JS基础
date: 2024-06-29T22:48:00
article: false

---
# 1 JS的简介
## 1.1 JS的概念
- JS是一门运行在游览器中的轻量型，解释性语言。
- 它具有一下特点：
	- 解释性
		- 它不需要我们进行手动编译，直接通过编译器（也就是游览器或JS引擎）进行编译，边写边编译。
	- 单线程
		- JS是一门单线程语言，也就是它是一行一行去执行代码的，提高了编译效率，但在一些应用场景也变得羸弱，所以又提出了异步编程的方式，提高代码运行的效率。
	- 面向对象
		- 几乎所有的现代的编程语言都是面向对象的编程语言，JS 也不例外。所谓的面向对象，指将一组相关的功能（数据）统一封装到一个对象中，使用功能时无需考虑其实现的细节，直接找到对应的对象即可完成功能的调用。
	- 扩展ES
		- ECMAScript 只是为我们定义最基本的语法，像是数据类型（原始值、对象）、运算符、流程控制语句等内容。为了使 JS 可以适用于不同的场景，在不同的 JS 解释器中还为我们提供了不同的扩展以增强其功能。像是浏览器中的 DOM、BOM 使得我们可以通过 JS 操作网页和浏览器。NodeJS 中的 fs 模块可以使我们直接操作计算机系统中的各种文件。所以我们学习 JS 时，除了要学习 ES 标准以外，还要学习它的各种扩展，才能在不同的环境中发挥出 JS 的最大威力。
	- 函数式编程
		- 在 JavaScript 中函数是一等公民，它可以像其他类型的值一样赋值给任意变量，也可以作为参数传递给其他函数。所以在 JS 中函数是非常非常重要，通过函数式编程可以编写出功能强大又灵活的代码。
# 2 JS的基本准备
## 2.1 2.1引入方式
- JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。
- 一般有三种方式：**行内，内部，外部**。
### 2.1.1 行内
- 一般直接写在HTML标签的属性中。
> ```html
> <button onclick="js代码">按钮</button>
> <a href="javascript:js代码;">超链接</a>
> ```
### 2.1.2 内部
- 通过 `script` 标签包裹 JavaScript 代码
> ```HTML
> <!DOCTYPE html>
> <html lang="en">
> <head>
> 	<meta charset="UTF-8">
> 	<title>JavaScript 基础 - 引入方式</title>
> </head>
> <body>
>   	<!-- 内联形式：通过 script 标签包裹 JavaScript 代码 -->
> 	  <script>
> 	    alert('嗨，欢迎来传智播学习前端技术！')
> 	  </script>
> </body>
> </html>
> ```
> 

### 2.1.3 外部
- 一般将 JavaScript 代码写在独立的以 `.js` 结尾的文件中，然后通过 `script` 标签的 `src` 属性引入。
> ```html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>   <meta charset="UTF-8">
>   <title>JavaScript 基础 - 引入方式</title>
> </head>
> <body>
>   <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 -->
>   <script src="demo.js"></script>
> </body>
> </html>
> ```

## 2.2 注释和结束符
### 2.2.1 单行注释

```js
// 这种是单行注释的语法
// 一次只能注释一行
// 可以重复注释
//document.write('嗨，欢迎来传智播学习前端技术！');
```

### 2.2.2 多行注释

```js
/* 这种的是多行注释的语法 */
/*
更常见的多行注释是这种写法
在些可以任意换行
多少行都可以
*/
/*document.write('嗨，欢迎来传智播学习前端技术！')*/
```
**注：编辑器中单行注释的快捷键为 `ctrl + /`**

## 2.3 结束符
- JS中每一条语句都应该以;结尾，但是JS解释器中有自动添加分号的机制，所以即使不加括号JS解释器会自动根据代码的上下文添加分号，虽然在极少数的情况下会加错，但不写分号依然是偷懒的不错选择，所以加不加;完全看你自己的心情。

## 2.4 大小写
- JS会严格区分字母的大小写，A和a是两个东西，所以注意区分。

## 2.5 忽略空格
- 和HTML相同，JS中的多个空格和换行会被忽略，所以可以借助空格或换行来对代码进行格式化，不会影响代码的运行逻辑。

## 2.6 输入和输出

### 2.6.1 输出

```js
alert()
document.wreit()
console.log()

```

### 2.6.2 输入

```js
prompt()

```

## 2.7 字面量
- 字面量其实就是一个值,它所代表的含义就是它字面的意思
	- 比如:1 2 3 4 100 "hello" true null ....
# 3 JS的基础语法

## 3.1 变量
- 理解变量是计算机存储数据的“容器”，变量可以用“存储”字面量
- 并且变量中存储的字面量可以随意的修改
- 通过变量可以对字面量描述，变量比较方便修改
	```js
	<script>
	  // x 符号代表了 5 这个数值
	  x = 5
	  // y 符号代表了 6 这个数值
	  y = 6
	    
	  //举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！
	
	  // 将用户输入的内容保存在 num 这个变量（容器）中
	  num = prompt('请输入一数字!')
	
	  // 通过 num 变量（容器）将用户输入的内容输出出来
	  alert(num)
	  document.write(num)
	</script>
	```

### 3.1.1 声明变量

> - `let 变量名`
> - 声明(定义)变量有两部分构成：声明关键字、变量名（标识）
> - `let` 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语
> - `age` 即变量的名称，也叫标识符

**注意：**`let` 和 `var` 都是 JavaScript 中的声明变量的关键字，推荐使用 `let` 声明变量！！！

### 3.1.2 变量赋值
- 声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。
	```js
	  <script> 
	    // 声明(定义)变量有两部分构成：声明关键字、变量名（标识）
	    // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语
	    // age 即变量的名称，也叫标识符
	    let age
	    // 赋值，将 18 这个数据存入了 age 这个“容器”中
	    age = 18
	    // 这样 age 的值就成了 18
	    document.write(age)
	    
	    // 也可以声明和赋值同时进行
	    let str = 'hello world!'
	    alert(str);
	  </script>
	```

### 3.1.3 变量名命名规则
- 关于变量的名称（标识符）有一系列的规则需要遵守：
	1. 只能是字母、数字、下划线、$，且不能能数字开头
	2. 字母区分大小写，如 `Age` 和 `age` 是不同的变量
	3. JavaScript 内部已占用于单词（关键字或保留字）不允许使用
	4. 尽量保证变量具有一定的语义，见字知义
> **注**：
> 所谓关键字是指 JavaScript 内部使用的词语，如 `let` 和`var`，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。

```js
let age = 18 // 正确
let age1 = 18 // 正确
let _age = 18 // 正确

// let 1age = 18; // 错误，不可以数字开头
let $age = 18 // 正确
let Age = 24 // 正确，它与小写的 age 是不同的变量
// let let = 18; // 错误，let 是关键字
let int = 123 // 不推荐，int 是保留字
```

## 3.2 常量
- 概念：使用 `const` 声明的变量称为“常量”。

- 使用场景：当某个变量永远不会改变的时候，就可以使用 `const` 来声明，而不是 `let`。

- 命名规范：和变量一致

	```js
	const PI = 3.14
	```

## 3.3 数据类型
- 计算机世界中的万事成物都是数据。

- 计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型：
- JS中有两大数据类型，分别是 **基本数据类型(原始值)** 和 **引用数据类型**。
1. **基本数据类型**
	1. 数值（Number）
    1. 大整数（BigInt）
    2. 字符串（String）
    3. 布尔值（Boolean）
    4. 空值（Null）
    5. 未定义（Undefined）
    6. 符号（Symbol）

2. **引用数据类型**
	1. 对象（Object）
	2. 函数（Function）
	3. 数组（Array）


> **注**：通过 `typeof` 关键字检测数据类型

```
// 检测 1 是什么类型数据，结果为 number
document.write(typeof 1)
```

### 3.3.1 基本数据类型

#### 3.3.1.1 数值（Number）

- 在JS中所有的整数和浮点数都是Number类型
	- 浮点数就是小数
- JS中的数值并不是无限大的,当数值超过一定范围后会显示近似值
- 数值非常大的时候会显示 `infinity` 表示一个特殊的数值无穷大
- 在js中进行一些精度比较高的运算时要十分注意（浮点运算丢精度）
- `NaN` 是一个特殊的数值，表示非法数值 （not a number）

	```js
	let score = 100 // 正整数
	let price = 12.345 // 小数
	let temperature = -40 // 负数
	```

#### 3.3.1.2 大整数（BigInt）
- 大整数用来表示一些比较大的整数
    - 大整数使用n结尾,它可以表示的数字范围是无限大
    - 大整数只能和大整数计算
    - 其他进制的数值
        - 二进制：0b
        - 八进制：0o
        - 十六进制：0x

#### 3.3.1.3 字符串（String）

通过单引号（`' '`） 、双引号（`" "`）或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。

> **注意事项**：
> - 无论单引号或是双引号必须成对使用
> - 单引号/双引号可以互相嵌套，但是不以自已嵌套自已
> - 必要时可以使用转义符 \，输出单引号或双引号

##### 3.3.1.3.1 转义字符（`\`）
- `\"`  -->  `=`
- `\'`   -->  `'`
- `11` --> `11`
- `\t`  --> `制表符`
- `\n` --> `换行`
##### 3.3.1.3.2 模版字符串
- 使用反单引号【 ` 】 来表示模板字符串
	- 可以换行
	- 模板字符串中可以嵌入变量
		- let b = 10   console.log(`b =${b}`）,那打印出来就是 `b = 10`
	- 使用 `typeof`  进行检查数据类型时会反馈 `string`
#### 3.3.1.4 布尔值（Boolean）
- 布尔值主要用来进行逻辑判断
    - 布尔值只有两个true 和 false
        - true 真  1
        - false 假 0
#### 3.3.1.5 空值（Null）
- 用来表示空对象
    - 空值只有一个 `null`
    - 使用 `typeof` 来检查 会返回 `object`
    - 使用 `typeof` 无法检查空值
#### 3.3.1.6 未定义（Undefined）
- 未定义是比较特殊的类型，只有一个值 `undefined`，只声明变量，不赋值的情况下，变量的默认值为 `undefined`，一般很少【直接】为某个变量赋值为 `undefined`。
#### 3.3.1.7 符号（Symbol）
- 用来创建一个唯一的标识
    - 使用 `typeof` 检查符号时会返回 `"symbol”`

## 3.4 类型转换

- 转换为字符串
    - 显式转换
        - `String()` 函数
    - 隐式转换
        - `+""`  算数运算符  加减`""`空值 

- 转换为数值
    - 显式转换
        - `Number()`函数
    - 隐式转换
        + `+`
- 转换为布尔值
    - 显式转换
        - `Boolean()`
    - 隐式转换
        - `!!`

### 3.4.1 显式转换

#### 3.4.1.1 转换为字符串
> 1. 调用 `toString()` 方法将其他类型转换为字符串
> 	- 调用xxx的yyy方法
> 		--> `a.toString（）`
> 	- 由于 `null` 和 `undefined` 中没有 `toString()`
> 		- 所以对这两个东西调用toString()时会报错
> 2. 调用 `String()` 函数将其他类型转换为字符串
> 	- 调用xxx函数  `String()`
> 		--> `xxx()`
> 	- 原理:
> 		- 对于拥有`toString()`方法的值调用`String()`函数时
> 			- 实际上就是在调用`toString()`方法
> 		- 对于`null`,则直接转换为`“null"`
> 		- 对于`undefined`,直接转换为`"undefined"`
> 

#### 3.4.1.2 转换为数值 
- 将其他的数据类型转换为数值
> 1. 使用 `Number()` 函数来将其他类型转换为数值
> 	- 转换的情况:
> 		- 字符串:
> 			- 如果字符串是一个合法的数字,则会自动转换为对应的数字
> 			- 如果字符串不是合法数字,则转换为 `NaN` 
> 			- 如果字符串是空串或纯空格的字符串,则转换为 `0`
> 		- 布尔值:
> 			- `true` 转换为 `1`, `false` 转换为 `0`
> 		- `null`       转换为 `0`
> 		- `undefined`  转换为 `NaN`
> 2. 专门用来将字符串转换为数值的两个方法
> 	- `parseInt()`    将一个字符串转换为一个整数
> 		- 解析时会从左到右解析字符串，直到读取一个有效的字符串
> 		- 可以使用 `parseInt` 对小数取整
> 	- `parseFloat()`  将一个字符串转换为浮点数
> 		- 解析时会从左到右解析字符串，直到读取一个有效的小数位

#### 3.4.1.3 转换为布尔值
- 将其他的数据类型转换为布尔值
> - 使用 `boolean()` 函数进行转换
> 	- 转换的情况:
> 		- 数字:
> 			- `0` 和 `NaN` 转换为false
> 			- 其余是 `true`
> 		- 字符串:
> 			- 空串 转换为 `false`
> 			- 其余是`true`
> 		- `null`和`undefined` 都转换为 `false`
> 		- 对象都会转换为`true`
> 	- 所有表示空性的没有的错误的值都会转换为`false`:
> 		- `0`、`NaN`、空串、`null`、`undefined`、`false`

## 3.5 运算符
- 运算符可以用来对一个或多个操作数(值)进行运算
### 3.5.1 算术运算符
| 运算符 | 作用                         |
| --- | -------------------------- |
| +   | 求和                         |
| -   | 求差                         |
| *   | 求积                         |
| /   | 求商                         |
| %   | 取模（取余数），开发中经常用于作为某个数字是否被整除 |
| **  | 幂运算                        |
> **注意**：在计算失败时，显示的结果是 `NaN （not a number）`
> 
> 1. 算术运算时,除了字符串的加法
> 	其他运算的操作数是非数值时,都会转换为数值然后再运算
> - 可以利用这一特点来完成类型转换
> 	- 可以通过为任意类型+一个空串的形式来将其转换为字符串
> 	- 其原理和String()函数相同,但使用起来更加简洁


### 3.5.2 赋值运算符

- 用来将一个值赋值给一个变量，`=` 将等号右边的值赋予给左边, 要求左边必须是一个容器

| 运算符 | 作用                             |
| --- | :----------------------------- |
| +=  | 加法赋值   `a += n 等价于 a = a+n`    |
| -+  | 减法赋值  `a -= n 等价于a=a-n`        |
| *=  | 乘法赋值  `a *=  n 等价于 a = a * n`  |
| /=  | 除法赋值  `a /= n 等价于 a= a / n`    |
| %=  | 取余赋值  `a % = n 等价于 a =a  % n`  |
| **= | 取幂赋值  `a **= n 等价于 a = a ** n` |

### 3.5.3 一元的`±`
> - 正号`+`
> 	- 不会改变数值的符号
> - 负号`-`
> 	- 可以对数值进行符号位取反
> 	- 当我们对非数值类型进行正负运算时,会先将其转换为数值然后再运算

### 3.5.4 自增自减运算符  ++  --
> - 自增运算符
> 	- ++ 使用后会使得原来的变量立刻增加1
> 	- 自增分为前自增(++a)和后自增(a++)
> 	- 无论是++a还是a++都会使原变量立刻增加1
> 	- 不同的是++a和a++所返回的值不同
> 		- a++ 是自增前的值  旧值
> 		- ++a 是自增后的值  新值
> - 自减运算符
> 	- -- 使用后会使得原来的变量立刻增加1
> 	- 自增分为前自增(--a)和后自增(a--)
> 	- 无论是--a还是a--都会使原变量立刻增加减少1
> 		- a-- 是自减前的值  旧值
> 		- --a 是自减后的值  新值

### 3.5.5 逻辑运算符
| 符号   | 名称  | 日常读法 | 特点                     | 口诀      |
| ---- | --- | ---- | ---------------------- | ------- |
| &&   | 逻辑与 | 并且   | 符号两边有一个假的结果为假          | 一假则假    |
| \|\| | 逻辑或 | 或者   | 符号两边有一个真的结果为真          | 一真则真    |
| !    | 逻辑非 | 取反   | true变false  false变true | 真变假，假变真 |

| A     | B     | A && B | A \|\| B | !A    |
| ----- | ----- | ------ | -------- | ----- |
| false | false | false  | false    | true  |
| false | true  | false  | true     | true  |
| true  | false | false  | true     | false |
| true  | true  | true   | true     | false |

### 3.5.6 比较运算符
| 运算符 | 作用                    |
| --- | --------------------- |
| >   | 左边是否大于右边              |
| <   | 左边是否小于右边              |
| >=  | 左边是否大于或等于右边           |
| <=  | 左边是否小于或等于右边           |
| === | 左右两边是否`类型`和`值`都相等（重点） |
| ==  | 左右两边`值`是否相等           |
| !=  | 左右值不相等                |
| !== | 左右两边是否不全等             |
#### 3.5.6.1 （`==`）相等运算符
- 相等运算符,用来比较两个值是否相等
- 使用相等运算符比较两个不同类型的值时,
	- 它会将其转换为相同的类型(通常转换为数值)然后再比较
	- 类型转换后值相同也会返回 `true`
- `null` 和 `undefined` 进行相等比较时会返回 `true`
- `NaN` 不和任何值相等,包括它自身

#### 3.5.6.2 （`===`）全等运算符
- 全等运算符,用来比较两个值是否全等
- 它不会进行自动的类型转换,如果两个值的类型不同直接返回 `false`
- `null` 和 `undefined` 进行全等比较时会返回 `false`
	-   `result = 1 === "1" // false`
	- `result = null === undefined // false`

#### 3.5.6.3 (`!=`) 不等运算符
- 不等,用来检查两个值是否不相等
- 会自动的进行类型转换

#### 3.5.6.4 (`!==`) 不全等运算符
- 不全等,比较两个值是否不全等
- 不会自动的类型转换
### 3.5.7 运算符优先级
- 在表格中位置越靠上的优先级越高,优先级越高越先执行,优先级一样自左向右执行
- 优先级我们不需要记忆,甚至表格都不需要看
- 因为 () 拥有最高的优先级,使用运算符时,如果遇到拿不准的,可以直接通过 ()来改变优先级即可
## 3.6 语句
### 3.6.1 表达式和语句
![[1671017924981.png]]

### 3.6.2 分支语句
- 分支语句可以根据条件判定真假，来选择性的执行想要的代码

- 分支语句包含：
	1. if分支语句（重点）
	2. 三元运算符
	3. switch语句

#### 3.6.2.1 if分支语句
```js
if(条件表达式) {
  // 满足条件要执行的语句
}
```

- 小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码；为false，则不执行大括号里面代码

- 小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()

- 如果大括号只有一个语句，大括号可以省略，但是，俺们不提倡这么做~

#### 3.6.2.2 if双分支语句

```js
if (条件表达式){
  // 满足条件要执行的语句
} else {
  // 不满足条件要执行的语句
}
```

```js
// 1. 用户输入
let uname = prompt('请输入用户名:')
let pwd = prompt('请输入密码:')
// 2. 判断输出
if (uname === 'pink' && pwd === '123456') {
  alert('恭喜登录成功')
} else {
  alert('用户名或者密码错误')
}
```
#### 3.6.2.3 if 多分支语句
- 适合于有多个条件的时候
	```js
	// 1. 用户输入
	let score = +prompt('请输入成绩：')
	// 2. 判断输出
	if (score >= 90) {
	  alert('成绩优秀，宝贝，你是我的骄傲')
	} else if (score >= 70) {
	  alert('成绩良好，宝贝，你要加油哦~~')
	} else if (score >= 60) {
	  alert('成绩及格，宝贝，你很危险~')
	} else {
	  alert('成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~')
	}
	```

#### 3.6.2.4 三元运算符（三元表达式）

**使用场景**： 一些简单的双分支，可以使用  三元运算符（三元表达式），写起来比 if  else双分支 更简单

**符号**：? 与 : 配合使用

语法：
```js
条件 ? 表达式1 ： 表达式2
```

 执行过程 ：
- 如果条件为真，则执行表达式1
- 如果条件为假，则执行表达式2
	```js
	// 1. 用户输入 
	let num = prompt('请您输入一个数字:')
	// 2. 判断输出- 小于10才补0
	// num = num < 10 ? 0 + num : num
	num = num >= 10 ? num : 0 + num
	alert(num)
	```

#### 3.6.2.5 switch语句
```js
switch（表达式）{
	case 表达式：
		- break
	case 表达式：
		- break
	default
}
```

- 执行的流程
    - switch语句在执行时,会依次将 `switch` 后的表达式和 `case` 后的表单式进行全等比较
        - 如果比较结果为 `true`,则自当前 `case` 处开始执行代码
        - 如果比较结果为 `false` ,则继续比较其他 `case` 后的表达式,直到找到`true`为止
        - 如果所有的比较都是 `false` ,则执行 `default` 后的语句。

>**注意**:
>    - 当比较结果为 `true` 时,会从当前 `case` 处开始执行代码
>        - 也就是说 `case` 是代码执行的起始位置
>    - 这就意味着只要是当前 `case` 后的代码,都会执行
>    - 可以使用 `break` 来避免执行其他的 `case`

- 例子：
```js
switch (age) {
	case age >= 80):
	alert(''你比楼上那位还年轻不小!'')
	break  // 退出switch
	case age >= 60 :
	alert('你已经退休了!')
	break  // 退出switch
	case age >= 30:
	alert('你已经步入中年了!’)
	break  // 退出switch
	case age >= 18:
	alert('你已经成年了!')
	default:
	alert('你还未成年!')
  }
```

- 总结
    - switch语句和if语句的功能是重复,switch能做的事if也能做,反之亦然
        - switch在多个全等判断时结构更清晰

### 3.6.3 循环语句
- 通过循环语句可以使指定的代码反复执行
- JS 中一共有三种循环语句
    - while 语句
    - do-while 语句
    - for 语句


#### 3.6.3.1 while循环
```js
while (条件表达式) {
   // 循环体    
}
```

- 执行流程:
    - `while` 语句在执行时,会先对条件表达式进行判断,
        - 如果结果为 `true`,则执行循环体,执行完毕,继续判断
        - 如果为 `true`,则再次执行循环体,执行完毕,继续判断,如此重复
        - 知道条件表达式结果为 `false` 时,循环结束

```js
// 1. 需求: 利用循环重复打印3次 '月薪过万不是梦，毕业时候见英雄'
let i = 1
while (i <= 3) {
  document.write('月薪过万不是梦，毕业时候见英雄~<br>')
  i++   // 这里千万不要忘了变量自增否则造成死循环
}


//练习2:假设银行存款的年利率为5%,问1000块存多少年可以变成5000块

// 创建一个变量表示钱数
let money = 1000

//1000 存一年是多少钱?
// money *= 1.05

//创建一个计数器来记录循环执行的次数
let year = 0

// 编写循环,计算存款的年数
while(money < 5000){
money *= 1.05//循环没执行一次,就相当于钱存了一年
year++
}
console.log(`需要存${year}年,最终的钱数为${money}元!`)//一共需要33年，共存钱5003.18854203379
```

> **循环三要素**：
> 1. 初始值 （经常用变量）//let money = 1000
> 2. 终止条件//money < 5000)
> 3. 变量的变化量//year++

#### 3.6.3.2 for 循环

- `for` 循环和 `while` 没有本质区别,都是用来反复执行代码
- 不同点就是语法结构,`for`循环更加清晰
- 执行流程:
    1. 执行初始化表达式,初始化变量
    2. 执行条件表达式,判断循环是否执行(`true` 执行,`false` 终止)
    3. 判断结果为 `true`,则执行循环体
    4. 执行更新表达式,对初始化变量进行修改
    5. 重复 `2`,知道判断为 `false` 为止
> **注意：**
> 1. 初始化表达式,往往在整个的生命周期中只会执行1次
> 2. `for` 循环中的三个表达式都可以省略
> 3. 使用 `let` 在 `for循环` 的 `()` 中声明的变量是局部变量,只能在 `for循环` 内部访问
> 4. 使用 `var` 在 `for循环` 的 `()` 中声明的变量可以在 `for循环`的外部访问
	```js
	for(1初始化表达式 ; 2条件表达式 ; 3更新表达式){
	        语句 ...
	    }
	```

- 实例：
```js
//求100以内所以3的倍数的个数，以及他们的和
第一种方式
let count = 0  //设置计数器
let result = 0  //设置累加器
       //1初始化表达式，2条件表达式，3更新表达式
       for(let i = 1 ; i<=100 ; i++){  //获取100以内所有的数
        if(i % 3 === 0){  //获取3的倍数
            count++
            result = result + i //获取i倍数的总和，可以换做 result += i
        }
       }
       console.log(`3的倍数一共有${count}个,总和为${result}`);

第二种方式
let count = 0  //设置计数器
let result = 0  //设置累加器
for(let i=3; i<=100; i+=3){
    count++
    result.+=i
}
console.log('3的倍数一共有${count}个,总和为${result}`)
```

#### 3.6.3.3 中止循环

- `break`   
	- 中止整个循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用（提高效率）  
	- `break` 用来终止 switch 和循环语句
    - `break` 执行后,当前的 switch 或循环会立刻停止
    - `break` 会终止离他最近的循环

- `continue`  中止本次循环，一般用于排除或者跳过某一个选项的时候
	```js
	let i = 1
	while (i <= 5) {
		console.log(i)
		if (i === 3) {
			break  // 退出循环
		}
		i++
	 }
	
	
	let i = 1
	while (i <= 5) {
		if (i === 3) {
			i++
			continue
		}
		console.log(i)
		i++
	}
	```



#### 3.6.3.4 无限循环

1. `while(true)` 来构造“无限”循环，需要使用`break`退出循环。（常用）

2. `for(;;)` 也可以来构造“无限”循环，同样需要使用`break`退出循环。
	```js
	// 无限循环  
	// 需求： 页面会一直弹窗询问你爱我吗？
	// (1). 如果用户输入的是 '爱'，则退出弹窗
	// (2). 否则一直弹窗询问
	
	// 1. while(true) 无限循环
	// while (true) {
	//   let love = prompt('你爱我吗?')
	//   if (love === '爱') {
	//     break
	//   }
	// }
	
	// 2. for(;;) 无限循环
	for (; ;) {
	  let love = prompt('你爱我吗?')
	  if (love === '爱') {
	    break
	  }
	}
	```

## 3.7 对象
- 对象是JS中的一种复合数据类型,
- 它相当于一个容器,在对象中可以存储各种不同类型数据
	- 对象中存储的数据,我们称为属性
- 原始值只能用来表示一些简单的数据,不能表示复杂数据


### 3.7.1 对象的创建，添加，读取
#### 3.7.1.1 创建对象
1. 通过new()构造函数创建
	```js
	let obj = Object()
	```
1. 通过字面量创建
	```js
	let obj1 = {}
	```
#### 3.7.1.2 添加属性（对象里面存储的数据）

1. 通过new()构造函数创建的对象
	```js
	let obj = Object()
	    obj.name = "孙悟空"
	    obj.age = "10"   
	```

1. 通过字面量创建的对象
	```js
	let obj = {
		name : "孙悟空"
		age : 18
	}
	```

#### 3.7.1.3 读取，修改，删除属性
```js
//读取对象
obj.name
//修改属性
let obj = Object()
    obj.name = "孙悟空"
    obj.age = "10" 
    obj.name = "Tom sun"
//删除属性
delete obj.name
//继续读取没有属性
console.log（obj.name）//返回undefined
```

### 3.7.2 属性名字和属性值
#### 3.7.2.1 属性名字
- 通常属性名就是一个字符串,所以属性名可以是任何值,没有什么特殊要求
	- 但是如果你的属性名太特殊了,不能直接使用,需要使用`[]`来设置
	- 虽然如此,但是我们还是强烈建议属性名也按照标识符的规范命名

- 也可以使用符号(symbol)作为属性名,来添加属性
	- 获取这种属性时,也必须使用 `symbol`
	- 使用 `symbol` 添加的属性,通常是那些不希望被外界访问的属性

- 使用`[]`去操作属性时,可以使用变量
> ```js
> //属性名就是一个字符串,所以属性名可以是任何值
> obj.if = "哈哈哈"
> obj.let = "hhh"
> //但是如果你的属性名太特殊了,不能直接使用,需要使用[]来设置
> obj["12345678##@@"] = "HHH"//不建议
> //可以使用符号(symbol)作为属性名
> obj[mySymbol] = "通过symbol添加属性"
> //使用[]去操作属性时,可以使用变量
> let str = "address"
> obj[str] = "花果山"//等价于obj["address"] = "花果山"
> ```



#### 3.7.2.2 属性值
- 对象的属性值可以是任意的数据类型,
- 也可以是一个对象
> ```js
> //对象的属性值可以是任意的数据类型
> obj.a = "字符串"//字符串
> obj.b = 1      //数值
> obj.c = 123n   //大整数
> obj.d = true   //布尔值
> //对象的属性值也可以是一个对象
> obj.aa = object（）
> obj.aa.name= 孙悟空
> ```

### 3.7.3 typeof  和 in 运算符

- 使用 `typeof` 检查一个对象时,会返回 `object`
    
- in 运算符
	- 使用 `in运算符` 检查对象中是否含有一个属性值
		- 如果有返回 `true`
		- 没有返回 `false`
	```js
	//使用typeof检查一个对象时,会返回object
	console.log（typeof obj）//object
	
	//使用 in 运算符 检查对象中是否含有一个属性值
	console.log（"name" in obj）
	```

### 3.7.4 枚举对象的属性
- 指将对象中的所有的属性全部获取。
	```js
	let obj ={
			name："孙悟空",
			age:"18",
			gender:"男",
			[Symbol()]:"测试"
		}
		for(let propName in obj){
			console.log(propName, obj[propName])//name 孙悟空 //age 10 //gender 男
		}
	```
```
	> **注意**:并不是所有的属性都可以枚举,比如 使用符号添加的属性
```
### 3.7.5 可变类型
- 对象属于可变类型
- 对象创建完成后,可以任意的添加删除修改对象中的属性
> **注意:**
> 
> - 当对两个对象进行相等或全等比较时,比较的是对象的内存地址
> 	- 如果有两个变量同时指向一个对象,
>	 	- 通过一个变量修改对象时,对另外一个变量也会产生影响
>
>原始值都属于不可变类型,一旦创建就无法修改
在内存中不会创建重复的原始值

### 3.7.6 变量和对象
- 修改对象
	- 修改对象时,如果有其他变量指向该对象则所有指向该对象的变量都会收到影响

- 修改变量
	- 修改变量时,只会影响当前的变量
	
	- 在使用变量存储对象时,很容易因为改变变量指向的对象,提高代码的复杂度
		所以通常情况下,声明存储对象的变量时会使用 `const`

## 3.8 面相对象编程（OOP）

1. 程序是干嘛的?
	-程序就是对现实世界的抽象(照片就是对人的抽象)
1. 对象是干嘛的?
	- 一个事物抽象到程序中后就变成了对象
	- 在程序的世界中,一切皆对象
1. 面向对象的编程
	- 面向对象的编程指,程序中的所有操作都是通过对象来完成
	- 做任何事情之前都需要先找到它的对象,然后通过对象来完成各种操作

- 心仪的女人:王老五
    - 一个事物通常由两部分组成:数据和功能
    - 一个对象由两部分组成:属性和方法
    - 事物的数据到了对象中,体现为属性
    - 事物的功能到了对象中,体现为方法
### 3.8.1 类（class）
#### 3.8.1.1 类的基本概念
- 使用Object创建对象的问题:
    - 无法区分出不同类型的对象
    - 不方便批量创建对象

- 在JS中可以通过类(class)来解决这个问题:
    - 类是对象模板,可以将对象中的属性和方法直接定义在类中
        - 定义后,就可以直接通过类来创建对象
    - 通过同一个类创建的对象,我们称为同类对象
        - 可以使用 `instanceof` 来检查一个对象是否是由某个类创建
        - 如果某个对象是由某个类所创建,**则我们称该对象是这个类的实例**

- 语法:
    - `class 类名 {}`  //类名要使用大驼峰命名
    - `const 类名= class {}`

- 通过类创建对象
    - new 类()


#### 3.8.1.2 类的属性
- 类的代码块,默认就是**严格模式**,
	- 类的代码块是用来设置对象的属性的,不是什么代码都能写
- 实例属性
	- 只能通过实例访问
- 静态属性
	- 只能通过类去访问

	```js
	class Person{
	    name = "孙悟空"  //实例属性
	    age ="18"       //实例属性
	    static test = "text静态属性" //静态属性，只能通过类去访问  Person.text
	}
	p1 = new Person()
	console.log(p1.name) //实例属性,只能通过实例访问
	```

#### 3.8.1.3 类的方法
- 实例方法
	- 实例属性,只能通过实例访问

- 静态方法
	- 调用静态方法  通过类调用

	```js
	class Person{
	    sayHello(){
	        console.log("hhh")
	    }//实例方法
	    static test(){
	        console.log("OOO")
	    }//静态方法
	
	const p1 = new Person()
	p1.sayHello()  //调用实例方法
	console.log(p1.sayHello) //实例属性,只能通过实例访问
	
	Person.test()  //调用静态方法  通过类调用
	
	```

#### 3.8.1.4 类中的构造函数（`constructor`）
- 在类中可以添加一个特殊的方法 `constructor`
    - 该方法我们称为构造函数(构造方法)
    - 构造函数会在我们调用类创建对象时执行
	```js
	class Person{
	    constructor(name,age,gender){
	        this.name = name
	        this.age = age
	        this.gender = gender
	    }
	}
	const p1 = new Person("孙悟空",180,"男")
	const p2 = new Person("猪八戒",280,"男")
	const p3 = new Person("沙和尚",380,"男")
	console.log(p1)
	console.log(p2)
	console.log(p3)
	```

### 3.8.2 封装、继承和多态
- 面向对象的特点:
    - **封装**、**继承**和**多态**
#### 3.8.2.1 封装
1. 封装
	- 对象就是一个用来存储不同属性的容器
	- 对象不仅存储属性,还要负责数据的安全
	- 直接添加到对象中的属性,并不安全,因为它们可以被任意的修改
	- 如何确保数据的安全:
		1. 私有化数据
			- 将需要保护的数据设置为私有,只能在类内部使用
		2. 提供 `setter` 和 `getter` 方法来开放对数据的操作
			- 属性设置私有,通过 `getter` `setter` 方法操作属性带来的好处
				1. 可以控制属性的读写权限
				2. 可以在方法中对属性的值进行验证

> - 封装主要用来保证数据的安全
> - 实现封装的方式:
> 	1. 属性私有化 加 `#`
> 	2. 通过`getter`和`setter`方法来操作属性
> 		get 属性名(){
> 		return this.#属性
> 		}
> 		set 属性名(参数){
> 		return this.#属性 = 参数
> 		}

- 实例：
```js
class Person{
    #address = "花果山" //实例使用#开头就变成了私有属性,私有属性只能在类内部访问
    #name 
    #age 
    #gender 
    constructor(name,age,gender){
        this.name = name
        this.age = age
        this.gender = gender
    }
    
    getAge(){
        return this.#age
    }//get 方法可以提供访问
    
    setAge(age){
        this.#age = age
    }//setter方法 用来设置加密属性
    
    setAge(age){
        if(age >= 0){
            this.#age = age
        }//可以用来判断数据合法性
    }
    //js标准getter和 setter 方法
    get gender(){
        return this.#gender
    }
    
    set gender(gender){
         this.#gender = gender
    }
}
```



#### 3.8.2.2 多态
- 在JS中不会检查参数的类型,所以这就意味着任何数据都可以作为参数传递
    - 要调用某个函数,无需指定的类型,只要对象满足某些条件即可

实例：
```js
//定义一个函数,这个函数将接收一个对象作为参数,他可以输出hello并打印对象的name属性
class Person{
    constructor(name){
        this.name = name
    }
}
class Dog{
    constructor(name){
        this.name = name
    }
}
const p1 = new Person("孙悟空")
const p2 = new Dog("旺财")
function sayHello(a){
    console.log("hello" + a)
}
sayHello(p1)
```


#### 3.8.2.3 继承

- 可以通过 `extends` 关键来完成继承
- 当一个类继承另一个类时,就相当于将另一个类中的代码复制到了当前类中(简单理解)
- 继承发生时,被继承的类称为 父类(超类),继承的类称为 子类
- 通过继承可以减少重复的代码,并且可以在不修改一个类的前提对其进行扩展
- OCP 开闭原则
	- 程序应该对修改关闭,对扩展开放

- 面相对象的特点
    - 封装 –安全性
    - 继承 -扩展性
    - 多态–灵活性
	```js
	class Animal{
	            constructor(name){
	                this.name = name
	            }
	            sayHello(){
	                console.log("动物叫声")
	            }
	} 
	class Dog extends Animal{ 
	    //在子类中，可以通过创建同名方法来覆写父类的方法
	    sayHello(){
	        console.log("汪汪汪")
	            }
	}  //extends  继承
	class Cat extends Animal{
	    //重写构造函数
	    constructor(name){
	        //重写构造函数时，构造函数懂得第一行代码必须是super（）
	        super()  //调用父类的构造函数
	        this.age = age
	    }
	} //extends  继承
	const dog = new Dog("旺财")
	const cat = new Cat("Tom")
	dog.sayHello() //动物叫声
	console.log(dog) //Dog {name: '旺财'}
	cat.sayHello() //动物叫声
	console.log(cat) //Cat {name: 'Tom'}
	
	```

### 3.8.3 对象的结构

- 对象中存储属性的区域实际有两个:
    1. **对象自身**
        - 直接通过对象所添加的属性,位于对象自身中
        - 在类中通过 x=y 的形式添加的属性,位于对象自身中
    2. **原型对象(prototype)**
        - 对象中还有一些内容,会存储到其他的对象里(原型对象)
        - 在对象中会有一个属性用来存储原型对象,这个属性叫做 __ proto
        - 原型对象也负责为对象存储属性,
            - 当我们访问对象中的属性时,会优先访问对象自身的属性,
            - 对象自身不包含该属性时,才会去原型对象中寻找
        - 会添加到原型对象中的情况:
            1. 在类中通过xxx(){}方式添加的方法,位于原型中
            2. 主动向原型中添加的属性或方法
- 实例：
	```js
	class Animal{
	            constructor(name){
	                this.name = name
	            }
	            sayHello(){
	                console.log("动物叫声")
	            } //存在于原型对象中
	} 
	const a = new Animal()
	a.sayHello = "hello" //存在于对象本身中
	```

#### 3.8.3.1 原型对象

- 访问一个对象的原型对象
    - `对象.__proto__`
    - `Object.getPrototypeOf( 对象 )`

- 原型对象中的数据:
    1. 对象中的数据(属性、方法等)
    2. constructor(对象的构造函数)
> **注意:**
> 
>     原型对象也有原型,这样就构成了一条原型链,根据对象的复杂程度不同,原型链的长度也不同
>     p对象的原型链: p对象 -- > 原型 -- > 原型 -- > `null`
>     obj对象的原型链: obj对象 -- > 原型 -- > `null`
- 型链:
    - 读取对象属性时,会优先对象自身属性,
        - 如果对象中有,则使用,没有则去对象的原型中寻找
        - 如果原型中有,则使用,没有则去原型的原型中寻找
        - 直到找到Object对象的原型(Object的原型没有原型(为 `null`))
            - 如果依然没有找到,则返回 `undefined`

	> **作用域链**, 是找变量的链,找不到会报错
	> **型链**, 是属性的链,找不到会返回 undefined


#### 3.8.3.2 原型的作用
- 所有的同类型对象它们的原型对象都是同一个,也就意味着,同类型对象的原型链是一样的
- 原型的作用:
    - 原型就相当于是一个公共的区域,可以被所有该类实例访问,
    - 可以将一个该类实例中,所有的公共属性(方法)统一存储到原型中
    - 这样我们只需要创建一个属性,即可被所有实例访问
- 在对象中有些值是对象独有的,像属性(name,age,gender)每个对象都应该有自己值,
    但是有些值对于每个对象来说都是一样的,像各种方法,对于一样的值没必要重复的创建

- JS中的继承就是通过原型实现的

#### 3.8.3.3 原型的修改

- 大部分情况下,我们是不需要修改原型对象
> **注意:**
> 
> 	千万不要通过类的实例去修改原型
> 		1. 通过一个对象影响所有同类对象,这么做不合适
> 		2. 修改原型先得创建实例,麻烦

- 处理通过 `__ proto __` 能访问对象的原型外,还可以通过类的 `prototype` 属性,来访问实例的原型
    - 修改原型时,最好通过通过类去修改
    - 好处:
        1. 一修改就是修改所有实例的原型
        2. 无需创建实例即可完成对类的修改

- 原则:
    1. 原型尽量不要手动改
    2. 要改也不要通过实例对象去改
    3. 通过 `类.prototype` 属性去修改
    4. 最好不要直接给`prototype`去赋值

- 实例：
	```js
	class Person{
	    name ="孙悟空"
	    age = 18
	    sayHello(){
	        console.log("hello，我是"，this.name)
	    }
	}
	const p1 = new Person()
	const p2 = new Person()
	p.__proto__.run = () => {
	    console.log("我在跑")
	}//直接通过实例去修改了原型，只影响p 实例
	Person.__proto__.fly = (){
	    console.log("我在飞~")
	}//通过类去修改，直接修改了父元素 类 同时影响通过类创建的所有实例
	```

#### 3.8.3.4 instance 和 hasOwn

- `instanceof` 用来检查一个对象是否是一个类的实例
	- `instanceof` 检查的是对象的原型链上是否有该类实例
		- 只要原型链上有该类实例,就会返回 `true`

- in 运算符 (属性名 in 对象)
	- 使用in运算符检查属性时,无论属性在对象自身还是在原型中,都会返回true

- Object.hasOwn（Object.hasOwn(对象,属性名)）
	- 用来检查一个对象的自身是否含有某个属性
- 实例：
	```js
	class Animal{}
	class Dog extends Animal{}
	const dog = new Dog()
	console.log(dog instanceof Dog)    //true  只要原型链上有该类实例,就会返回true
	console.log(dog instanceof Animal) //true  只要原型链上有该类实例,就会返回true
	//dog --> Animal实例 -->  Object实例 -->  Object原型
	console.log("sayHello" in p) //true  只要原型链上有该类实例,就会返回true
	console.log(Object.hasOwn(p,"sayHello")) 
	```

#### 3.8.3.5 new 运算符


 - new运算符是创建对象时要使用的运算符
    - 使用new时,到底发生了哪些事情:
    - 当使用new去调用一个函数时,这个函数将会作为构造函数调用,
        - 使用new调用函数时,将会发生这些事:
            1. 创建一个普通的JS对象(Object对象 {}),为了方便,称其为新对象
            2. 将构造函数的prototype属性设置为新对象的原型
            3. 使用实参来执行构造函数,并且将新对象设置为函数中的 `this`
            4. 如果构造函数返回的是一个非原始值,则该值会作为new运算的返回值返回(千万不要这么做)
                - 如果构造函数的返回值是一个原始值或者没有指定返回值,则新的对象将会作为返回值返回
                    - 通常不会为构造函数指定返回值

## 3.9 函数（Function）
### 3.9.1 函数的基本概况


- 函数也是一个对象
- 它具有其他对象所有的功能
- 函数中可以存储代码,且可以在需要时调用这些代码

- 语法:
	```js
	function 函数名(){
	语句...
	}
	```

- 调用函数:
	- 调用函数就是执行函数中存储的代码
	- 语法:
		- 函数对象()

- 使用typeof 检查函数时会返回 function


### 3.9.2 函数定义的方式
1. 函数声明
	```js
	function 函数名(){
	语句...
	}
	```
    
2. 函数表达式
	```js
	const 变量 =function(){
		语句...
	}
	```
1. 箭头函数
	```js
	()=>{
		语句...
	}
	```

### 3.9.3 函数的参数

1. 形式参数
	- 在定义函数时,可以在函数中指定数量不等的形式参数(形参)
	- 在函数中定义形参,就相当于在函数内部声明了对应的变量但是没有赋值
	- 形式参数可以设置默认值
		- 默认值在没有对应实际参数是使用

1. 实际参数
	- 在调用函数时,可以在函数的()传递数量不等的实参
	- 实参会赋值给其对应的形参
	- 参数:
		1. 如果实参和形参数量相同,则对应的实参赋值给对应的形参
		2. 如果实参多余形参,则多余的实参不会使用
		3. 如果形参多余实参,则多余的形参为 `undefined`
	- 参数的类型
		- JS中不会检查参数的类型,可以传递任何类型的值作为参数

> - 对象可以作为参数传递
> - 函数每次调用都会重新创建默认值

- 实例：
	```js
	//对象可以作为参数传递,传递的不是变量本身而是变量中储存的值
	function fn(a){
		console.log(a)//name:"孙悟空"
		console.log(a.name)//孙悟空
	}
	let obj = {name:"孙悟空"}
	fn(obj)
	
	//函数每次调用都会重新创建默认值
	    //情况一
	function fn(a = {name:"沙和尚"}){
	    comsole.log(a)//沙和尚
	    a.name = "唐僧"
	    comsole.log(a)//唐僧
	}
	fn() //沙和尚  唐僧
	fn() //沙和尚  唐僧    主要体现在第二次调用函数 对象的变化
	    //情况二
	let obj = {name:"沙和尚"}
	function fn(a = obj){
	    comsole.log(a)//沙和尚
	    a.name = "唐僧"
	    comsole.log(a)//唐僧
	}
	fn() //沙和尚  唐僧
	fn() //唐僧  唐僧    主要体现在第二次调用函数 对象的变化
	```
### 3.9.4 函数的返回值

1. 在函数中,可以通过 `return` 关键字来指定函数的返回值
	- 返回值就是函数的执行结果,函数调用完毕返回值便会作为结果返回

2. 任何值都可以作为返回值使用(包括对象和函数之类)
	- 如果 `return` 后不跟任何值,则相当于返回 `undefined`
	- 如果不写 `return` ,那么函数的返回值依然是 `undefined`

3. `return`-执行函数立即结束

- 实例：
```js
//1.在函数中,可以通过return关键字来指定函数的返回值
function sum(a,b){
    return a+b
}
sum(10,20)

//2.任何值都可以作为返回值使用(包括对象和函数之类)
function fn(){
    return {name:"tom sun"}//可以返回对象
    return ()=>alert(111) //可以返回函数
    return 111            //可以返回数值
    return "tom sun"      //可以返回字符串
    return 111n           //可以返回大整数
    return true           //可以返回布尔值
    return NaN            //可以返回NaN
    return undefined      //可以返回undefined
}
let result = fn()
console.log(fn());
        //如果return后不跟任何值,则相当于返回undefined
function fn(){
    return 
}
        //如果不写return,那么函数的返回值依然是undefined
function fn(){
}
//3.return-执行函数立即结束
function fn(){
    alert (111)
    return
    alert (222)//当执行完第一个返回值，函数立即结束，不会执行下面的返回值
}
```


### 3.9.5 windows 对象

- 在浏览器中,浏览器为我们提供了一个window对象,可以直接访问
    - window对象代表的是浏览器窗口,通过该对象可以对浏览器窗口进行各种操作
        除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
    - window对象的属性可以通过window对象访问,也可以直接访问
    - 函数就可以认为是window对象的方法

### 3.9.6 变量和函数的提升


- `var` 用来声明变量,作用和 `let` 相同,但是 `var` 不具有块作用域
    - 在全局中使用 `var` 声明的变量,都会作为 window对象 的属性保存
    - 使用 `function` 声明的函数,都会作为 window 的方法保存
    - 使用 `Let` 声明的变量不会存储在 window对象 中,而存在一个秘密的小地方(无法访问)
    - `var` 虽然没有块作用域,但有函数作用域

1. `var` 变量的提升
    - 使用 `var` 声明的变量,它会在所有代码执行前被声明
        - 所以我们可以在变量声明前就访问变量
	```js
	console.log(a)  //提前打印a，只会打印出undefined
	var a = 10      
	```
1. `let` 变量的提升
    - `let` 声明的变量实际也会提升,但是在赋值之前解释器
	```js
	console.log(a) //Cannot access 'a' before
	let a = 10
	```
1. 函数的提升
    - 使用函数声明创建的函数,会在其他代码执行前被创建
        - 所以我们可以在函数声明前调用函数
	```js
	fn()
	function fn(){
	    alert("我是一个函数")
	}
	```

### 3.9.7 作用域（scope）

- 作用域指的是一个变量的可见区域
- 作用域有两种:
> 1. 全局作用域
> 	- 全局作用域在网页运行时创建,在网页关闭时销毁
> 	- 所有直接编写到`scrip`t标签中的代码都位于全局作用域中
> 	- 全局作用域中的变量是全局变量,可以在任意位置访问
> 
> 2. 局部作用域
> 	1. 块作用域
> 		- 块作用域是一种局部作用域
> 		- 块作用域在代码块执行时创建,代码块执行完毕它就销毁
> 		- 在块作用域中声明的变量是局部变量,只能在块内部访问,外部无法访问
> 	2. 函数作用域
> 		- 函数作用域也是一种局部作用域
> 		- 函数作用域在函数调用时产生,调用结束后销毁
> 		- 函数每次调用都会产生一个全新的函数作用域
> 		- 在函数中定义的变量是局部变量,只能在函数内部访问,外部无法访问

#### 3.9.7.1 作用域链  (**就近原则**)
- 当我们使用一个变量时,
	- JS解释器会优先在当前作用域中寻找变量,
		1. 如果找到了则直接使用
		2. 如果没找到,则去上一层作用域中寻找,找到了则使用
		3. 如果没找到,则继续去上一层寻找,以此类推
		4. 如果一直到全局作用域都没找到,则报错 `xxx is not defined`
- 实例：
	```js
	let a = 11  //全局变量a
	function fn(){
	    let a = 22  //局部的代码块中的变量a
	    function fn2(){
		    let a = 33  //局部的代码块中嵌套的代码块中的变量a
		    console.log(a)  //根据就近原则 会打印fn2函数的a 33
	    }  
	}
	```




#### 3.9.7.2 立即执行函数(**IIFE**)
- 立即是一个匿名的函数,并它只会调用一次
- 可以利用IIFE来创建一个一次性的函数作用域,避免变量冲突的问题
- 实例：
	```js
	(function(){
	let a = 10
	console.log(111)
	}())；  //使用；隔开 防止游览器解析成一个函数（）
	(function(){
	# let a = 100
	console.log(222)
	}())；
	```

### 3.9.8 this 隐含参数

 - 函数在执行时,JS解析器每次都会传递进一个隐含的参数
    - 这个参数就叫做 `this`
    - `this`会指向一个对象
        - `this`所指向的对象会根据函数调用方式的不同而不同
            1. 以函数形式调用时,`this`指向的是`window`
            2. 以方法的形式调用时,`this`指向的是调用方法的对劇

#### 3.9.8.1 箭头函数
- ([参数])=>返回值
- 无参箭头函数:()=>返回值
- 例子:
	- 一个参数的: a => 返回值
	- 多个参数的: (a,b) => 返回值
	- 只有一个语句的函数:  () => 返回值
	- 只返回一个对象的函数: () => ({...})
	- 有多行语句的函数:  
		```
		()=>{
		        ....
		        return 返回值
		    }
		```

> 箭头函数没有自己的this,它的this有外层作用域决定
> 箭头函数的this和它的调用方式无关



### 3.9.9 严格模式

JS运行代码的模式有两种：
1. 正常模式
	- 默认情况下代码都运行在正常模式中,
		- 在正常模式,语法检查并不严格
		- 它的原则是:能不报错的地方尽量不报错
	- 这种处理方式导致代码的运行性能较差

2. 严格模式
	- 在严格模式下,语法检查变得严格
		1. 禁止一些语法
		2. 更容易报错
		3. 提升了性能

-  在开发中,应该尽量使用严格模式,
	- 这样可以将一些隐藏的问题消灭在萌芽阶段,
	- 同时也能提升代码的运行性能

```js
"use strict" //全局严格模式

functionfn(){
    "use strict"// 函数严格模式
}
```

## 3.10 数组（Array）

### 3.10.1 数组的概况
- 数组也是一种复合数据类型,在数组可以存储多个不同类型的数据
    - 数组中存储的是有序的数据,数组中的每个数据都有一个唯一的索引
        - 可以通过索引来操作获取数据
    - 数组中存储的数据叫做元素（`element`）
    - 索引(`index`)是一组大于 0 的整数
#### 3.10.1.1 创建数组
```js
const array = new Array()  //调用Array构造函数创建数组
const arr2 = []  //通过数组字面量创建数组
```
#### 3.10.1.2 向数组中添加元素
```js
const array = new Array() 
array[0] = 10
array[1] = 20
array[2] = 30  //Array构造函数 添加元素
    //array[100] = 100  非连续性数组  不建议使用 性能不好
const arr2 = [1, 2, 3, 4, 5]  //数组字面量数组 添加元素
```

#### 3.10.1.3 读取数组中的元素  语法：数组[索引]
`console.log(array[0])`  

#### 3.10.1.4 length
```js
console.log(array.length)  //获取数组的长度
array[array.length] = 55  //向数组最后添加元素  语法:数组[数组.length]=元素
array.length =2  //修改数组的元素
```
### 3.10.2 遍历数组

- 任何类型的值都可以成为数组中的元素
	```js
	let arr = [1, "hello",true, null, {name:"孙悟空"},()=>{}]
	```
- 创建数组时尽量要确保数组中存储的数据的类型是相同
	```js
	arr = [“孙悟空”,“猪八戒”,“沙和尚”]
	```

- 遍历数组简单理解,就是获取到数组中的每一个元素

	```js
	arr =[“孙悟空",“猪八戒”,“沙和尚”,“唐僧”,“白骨精”]
	// console.log(arr[0])
	// console.log(arr[1])
	// console.log(arr[2]) //一行行打印太麻烦
	
	for(let i=0; i<arr.length; i++){
	    console.log(arr[i])
	}//正向循环
	
	for(let i=arr.length-1; i>=0; i --){
	    console.log(arr[i])
	}//反向循环
	```

- 实例
	```js
	//打印出小于18岁的元素
	class Person {
	    constructor(name, age) {
	    this.name = name
	    this.age = age
	    }
	}
	const personArr = [
	    new Person("孙悟空",18),
	    new Person("沙和尚",38),
	    new Person("红孩儿",8),
	]
	    //console.log(personArr.length);
	for(let i=0; i<personArr.length; i++){
	    if(personArr[i].age < 18){
	        console.log(personArr[i])
	    }
	}   
	```

#### 3.10.2.1 `for-of` 语句
- `for-of` 语句可以用来遍历可迭代对象
	```js
	//for of 语句
	for(let value of personArr){
		if(value.age < 18){
			console.log(value)
		}
	} 

	const arr = ["孙悟空",“猪八戒",“沙和尚",“唐僧"]
	for(let value of arr){
	    console.log(value)
	}
	```

### 3.10.3 数组的方法
![[一些常用的方法#2 数组的方法(Array Method)]]














### 3.10.4 数组的拷贝
1. 浅拷贝(shallow copy)
    - 通常对对象的拷贝都是浅拷贝
    - 浅拷贝顾名思义,只对对象的浅层进行复制(只复制一层)
    - 如果对象中存储的数据是原始值,那么拷贝的深浅是不重要
    - 浅拷贝只会对对象本身进行复制,不会复制对象中的属性(或元素)
	```js
	const arr=[{name:"孙悟空”},{name:”猪八戒”}]
	const arr2 =arr.slice()// 浅拷贝
	const arr3= structuredClone(arr)//专门用来深拷贝的方法
	```
1. 深拷贝(deep copy)
    - 深拷贝指不仅复制对象本身,还复制对象中的属性和元素
    - 因为性能问题,通常情况不太使用深拷贝

1. ...展开运算符
    - 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
    - 通过它也可以对数组进行浅复制
	```js
	const arr=[{name:"孙悟空”},{name:”猪八戒”}]
	const arr3 = [arr[0], arr[1], arr[2]]
	const arr3 = [ ... arr]
	const arr3=["唐僧”, …. arr,“白骨精”]
	
	function sum(a, b, c) {
	    return a + b + c
	}
	const arr4 = [10, 20, 30]
	let result = sum(arr4[0], arr4[1], arr4[2])//
	result = sum( ... arr4)//通过它也可以对数组进行浅复制
	console.log(result)
	```
1. Object.assign
    - Object.assign(目标对象,被复制的对象)
    - 将被复制对象中的属性复制到目标对象里,并将目标对象返回
	```js
	const obj = {name:"孙悟空",age = 18}
	const obj2 =Object.assign({}, obj)//{name: '孙悟空', age: 18}
	const obj2 = {address:"花果山", age:28}//{address: '花果山', age: 18, name: '孙悟空'}
	const obj2 = {address:"花果山"，...obj，age:28}//{address: '花果山', name: '孙悟空', age: 18}
	Object.assign(obj2, obj)
	```

### 3.10.5 数组去重，排序
#### 3.10.5.1 去重
```js
//方法1
const arr =[8, 2,5, 9, 7, 5, 5,6, 4, 3, 1, 2]
    for(let i=0;i<arr.length;i++){
        for(let j= i+1; j<arr.length; j++){
            if (arr[i] === arr[j]) {
                arr.splice(j, 1)
                j--
            }
        }
    }
console.log(arr);
//方法2
const arr =[1,2,2,2,3,3,4,4,4,5,5,6,6,6,7,7,8,8,9,]
    for(let i=0;i<arr.length;i++){
        const index = arr.indexOf(arr[i], i+1)
        if(index !== -1){
            arr.splice(index, 1)
            i--
        }
    }
console.log(arr);
//方法3  非破坏性  创建新数组复制结果
const arr =[1,2,2,2,3,3,4,4,4,5,5,6,6,6,7,7,8,8,9,]
const newArr =[]
for(let element of arr){
    if(newArr.indexOf(element) === -1){
        newArr.push(element)
    }
}
console.log(newArr);
```
#### 3.10.5.2 排序
```js
冒泡排序  速度慢 适合数据量小的
const arr =[9, 8, 5, 7, 6, 3, 4, 1, 2, 0,]
for(let j=0; j<arr.length-1; j++){
    //console.log(arr[j])
    for(let i=0; i<arr.length-1; i++){
        //arr[i]为前边元素，arr[i]为后边元素
        if(arr[i] > arr[ i + 1 ]){
            let temp = arr[i]//创建临时变量存储arr[i]
            arr[i] = arr[i+1]//将arr[i+1]的值赋给arr[i]
            arr[i+1] = temp //修改arr[i+1]的值
        }
    }
}   
console.log(arr)
    //优化
const arr =[9, 8, 5, 7, 6, 3, 4, 1, 2, 0,]
for(let j=0; j<arr.length-1; j++){
    //console.log(arr[j])
    for(let i=0; i<arr.length-1-j; i++){
        //arr[i]为前边元素，arr[i]为后边元素
        if(arr[i] > arr[ i + 1 ]){
            let temp = arr[i]//创建临时变量存储arr[i]
            arr[i] = arr[i+1]//将arr[i+1]的值赋给arr[i]
            arr[i+1] = temp //修改arr[i+1]的值
        }
    }
}   
选择排序
console.time("计算速度")//计数器
const arr =[9, 9, 8, 8,5,9,6,3,4, 5, 7, 6, 3, 4, 1, 2, 0,]
//去重
for(let i=0; i<arr.length; i++){
    const index=arr.indexOf(arr[i],i+1)
    if(index !==-1){
        arr.splice(index,1)
        i--
    }
}
//排序
for(let i=0; i<arr.length-1; i++){
    for(let j=i+1; j<arr.length;j++){
        if(arr[i] > arr[j]){
            let temp = arr[i]
            arr[i]=arr[j]
            arr[j]=temp
        }
    }
    console.log(arr);
}
console.log(arr);
console.timeEnd("计算速度")
```

### 3.10.6 封装函数
```js
//封装函数
const arr = [9, 8, 5, 7, 6, 3, 4, 1, 2, 0,]
const arr2 =[9, 9, 8, 8,5,9,6,3,4, 5, 7, 6, 3, 4, 1, 2, 0,]
function sort(arr){
    //去重
    for(let i=0; i<arr.length; i++){
        const index=arr.indexOf(arr[i],i+1)
        if(index !==-1){
            arr.splice(index,1)
            i--
        }
    }
    //排序
    for(let i=0; i<arr.length-1; i++){
        for(let j=i+1; j<arr.length;j++){
            if(arr[i] > arr[j]){
                let temp = arr[i]
                arr[i]=arr[j]
                arr[j]=temp
            }
        }
    }
}
sort(arr2)//将常量arr2作为参数传入函数sort
console.log(arr2);//打印arr2
```

### 3.10.7 高阶函数
- 高阶函数
    - 如果一个函数的参数或返回值是函数,则这个函数就称为高阶函数
    - 为什么要将函数作为参数传递?(回调函数有什么作用?)
    - 将函数作为参数,意味着可以对另一个函数动态的传递代码
#### 3.10.7.1 回调函数
```js
function filter(arr,cb) {
    const newArr =[]//设置一个空数组
    for (let i = 0; i < arr.length; i++) {
        if (cb(arr[i])) {
            newArr.push(arr[i])
        }
    } 
    return newArr
}
const arr2 = [0,2,3,1,5,6,7,8,9,10,15,12,14,18,19]
result = filter(arr2,a => a %2 === 0) 
console.log(result);
```

#### 3.10.7.2 高阶函数的返回值

```js
希望在someFn()函数执行时,可以记录一条日志
在不修改原函数的基础上,为其增加记录日志的功能
可以通过高阶函数,来动态的生成一个新函数
function someFn() {
    return "hello"
}
function outer(cb){
    return () => {
        console.log(“记录日志 ~~~ ")
        const result = cb()//调用函数someFn()
        return result    //把调用结果作为返回值返回给匿名箭头函数
    }
}
let result = outer(someFn)
console.log(result)
```

### 3.10.8 闭包

- 闭包：  
	- 闭包就是能访问到外部函数作用域中变量的函数
1. 什么时候使用:
    - 当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包
1. 构成闭包的要件:
    1. 函数的嵌套
    2. 内部函数要引用外部函数中的变量
    3. 内部函数要作为返回值返回
2. 闭包的生命周期:
    1. 闭包在外部函数调用时产生,外部函数每次调用都会产生一个全新的闭包
    2. 在内部函数去失时销毁(内部函数被垃圾回收了,闭包才会消失)

> - 注意事项:
>     - 闭包主要用来隐藏一些不希望被外部访问的内容,
>         - 这就意味着闭包需要占用一定的内存空间
>     - 相较于类来说,闭包比较浪费内存空间(类可以使用原型而闭包不能),
>         - 需要执行次数较少时,使用闭包
>         - 需要大量创建实例时,使用类

> 函数的作用域，在函数创建时就已经确定的(词法作用域)，和调用的位置无关。

```js
//闭包的典型结构
function outer( ){
    let someVariable = "someValue"
    return function( ){
    console. log(someVariable)
    }
}
//函数的作用域
let a="全局变量a”
function fn( ){
    console.log(a)
}
function fn2(){
    let a="fn2中的a”
    fn()//打印"全局变量a”
.}
fn()//打印"全局变量a”
fn2()//打印"fn2中的a”
//闭包的生命周期
function outer2(){
    let num = 0
    return () => {
    num++
    console.log(num)    
    }
}
let fn1=outer2()//独立闭包
let fn2= outer2()// 独立闭包
fn1()
fn2()
fn1 = null//可以销毁闭包
fn2 = null
```

### 3.10.9 递归
- 调用自身的函数称为递归函数
- 递归的作用和循环是基本一直
> // 创建一个函数，可以用来求任意数的阶乘
> 1!  1
> 2!  1 x 2 = 2
> 3!  1 x 2 x 3 = 6
> ...
> 10!  1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 = xxx
> 
> 如果用递归来解决阶乘的问题？
>     5! = 4! x 5
>     4! = 3! x 4
>     3! = 2! x 3
>     2! = 1! x 2
>     1! = 1
> 
> 递归的核心思想就是将一个大的问题拆分为一个一个小的问题，小的问题解决了，大的问题也就解决了

- 编写递归函数，一定要包含两个要件：
    1. 基线条件 ——  递归的终止条件
    2. 递归条件 ——  如何对问题进行拆分

- 递归的作用和循环是一致的，不同点在于，递归思路的比较清晰简洁，循环的执行性能比较好
- 在开发中，一般的问题都可以通过循环解决，也是尽量去使用循环，少用递归
- 只在一些使用循环解决比较麻烦的场景下，才使用递归
- 实例：
	```js
	// 创建一个函数，可以用来求任意数的阶乘
	//使用循环解决
	function jieCheng(num){
	    // 创建一个变量用了记录结果
	    let result = 1
	    for(let i=2; i<=num; i++){
	        result *= i//result = result * i
	    }
	    return result
	}
	let result = jieCheng(3)
	console.log(result)
	
	//使用递归
	function jieCheng2(num){
	    // 基线条件
	    if(num === 1){
	        return 1
	    }
	    // 递归条件
	    // num! = (num-1)! * num
	    return jieCheng2(num-1) * num
	}
	result = jieCheng2(5)
	//递归原理
	jieCheng2(5)
	    - return jieCheng2(4) * 5
	     - return jieCheng2(3) * 4
	      - return jieCheng2(2) * 3
	        - return jieCheng2(1) * 2
	         - return 1
	```

### 3.10.10 可变参数/剩余参数

1. arguments
    - `arguments` 是函数中又一个隐含参数
    - `arguments` 是一个类数组对象（伪数组）
        和数组相似，可以通过索引来读取元素，也可以通过for循环变量，但是它不是一个数组对象，不能调用数组的方法
    - `arguments` 用来存储函数的实参，
        无论用户是否定义形参，实参都会存储到 `arguments` 对象中
        可以通过该对象直接访问实参

1. 可变参数，在定义函数时可以将参数指定为可变参数
    - 可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回
    - 可变参数的作用和 `arguments` 基本是一致，但是也具有一些不同点：
        1. 可变参数的名字可以自己指定
        2. 可变参数就是一个数组，可以直接使用数组的方法
        3. 可变参数可以配合其他参数一起使用

### 3.10.11 .call()  .apply()   .bind()

- 根据函数调用方式的不同，`this` 的值也不同：
    1. 以函数形式调用，`this` 是 `window`
    2. 以方法形式调用，`this` 是调用方法的对象
    3. 构造函数中，`this` 是新建的对象
    4. 箭头函数没有自己的this，由外层作用域决定
    5. 通过 `call` 和 `apply` 调用的函数，它们的第一个参数就是函数的 `this`
    6. 通过`bind`返回的函数，`this` 由 `bind`第一个参数决定（无法修改）

- 调用函数除了通过 `函数()` 这种形式外，还可以通过其他的方式来调用函数
    - 比如，我们可以通过调用函数的`call()`和`apply()`来个方法来调用函数
        - `函数.call()`
        - `函数.apply()`
        - `call` 和 `apply`除了可以调用函数，还可以用来指定函数中的`this`
        - `call`和`apply`的第一个参数，将会成为函数的`this`
        - 通过`call`方法调用函数，函数的实参直接在第一个参数后一个一个的列出来
        - 通过`apply`方法调用函数，函数的实参需要通过一个数组传递
	```js
	function fn2(a, b) {
	    console.log("a =", a, "b =", b, this)
	}
	fn2.call(obj, "hello", true)//通过call方法调用函数，函数的实参直接在第一个参数后一个一个的列出来
	fn2.apply(obj, ["hello", true])//通过apply方法调用函数，函数的实参需要通过一个数组传递
	```
- `bind()` 是函数的方法，可以用来创建一个新的函数
    - `bind`可以为新函数绑定`this`
    - `bind`可以为新函数绑定参数
	```js
	 function fn(a, b, c) {
	    console.log("fn执行了~~~~", this)
	    console.log(a, b, c)
	}
	const obj = {name:"孙悟空"}
	const newFn = fn.bind(obj, 10, 20, 30)//第一个参数绑定this，后面参数绑定形参
	 newFn()
	```
- 箭头函数没有自身的`this`，它的this由外层作用域决定，
    也无法通过`call` `apply` 和 `bind`修改它的`this` 
    箭头函数中没有`arguments`
## 3.11 内建对象

### 3.11.1 解构赋值
#### 3.11.1.1 解构赋值(数组)

1. 声明同时解构
	```js
	const arr = ["孙悟空", "猪八戒", "沙和尚"]
	# //声明三个变量，并将数组中的元素赋值给三个变量
	let     a,b,c
	a = arr[0]
	b = arr[1]
	c = arr[2]
	//解构赋值
	[a, b, c] = arr
	# // 声明同时解构
	let [d, e, f, g] = ["唐僧", "白骨精", "蜘蛛精", "玉兔精"] 
	```
1. 解构数组时，可以使用...来设置获取多余的元素
	```js
	# // 解构数组时，可以使用...来设置获取多余的元素
	let [n1, n2, ...n3] = [4, 5, 6, 7]//n1=4，n2=5，n3=6，7
	```
1. 可以设置默认值
	```js
	# //可以设置默认值
	let [d, e, f, g] = ["唐僧", "白骨精", "蜘蛛精", "玉兔精"] 
	;[d, e, f = 77, g = g] = [1, 2, 3]//f=77不赋值保持默认值，g=g不赋值用原来的值  玉兔精
	```
1. 对函数进行解构
	```js
	# //对函数进行解构
	function fn(){
	    return ["二郎神", "猪八戒"]
	}
	let [name1, name2] = fn()
	```
1. 可以通过解构赋值来快速交换两个变量的值
	```js
	# // 可以通过解构赋值来快速交换两个变量的值
	/*let temp = a1
	 a1 = a2
	 a2 = temp*/
	[a1, a2] = [a2, a1] // [20, 10]
	
	const arr2 = ["孙悟空", "猪八戒"]
	;[arr2[0], arr2[1]] = [arr2[1], arr2[0]]
	```

##### 3.11.1.1.1 二维数组    

- 数组中可以存储任意类型的数据，也可以存数组,
- 如果一个数组中的元素还是数组，则这个数组我们就称为是二维数组

1. **二维数组的遍历**
```js
const arr3 = [["孙悟空", 18, "男"], ["猪八戒" ,28, "男"]]

for(let stu of arr3){
     for(let v of stu){
        console.log(v)
    }
 }
```

1. **二维数组的解构**
```js
const arr3 = [["孙悟空", 18, "男"], ["猪八戒" ,28, "男"]]
let [[name, age, gender], obj] = arr3//解构给数组
console.log(name, age, gender)
console.log(obj)
```

#### 3.11.1.2 解构赋值(对象)

```js
const obj = { name: "孙悟空", age: 18, gender: "男" }

// 声明变量同时解构对象
const obj = { name: "孙悟空", age: 18, gender: "男" }
let { name, age, gender } = obj 
//常规方法
let name = obj.name
let age = onj.age
let gender = obj.gender

//先声明变量在解构
let name, age, gender
({ name, age, gender } = obj)

// 没有的属性返回undefined
let { address } = obj 

//别名，可以更改对应键值的名字
let {name:a, age:b, gender:c, address:d="花果山"} = obj
```

### 3.11.2 对象的序列化（JSON）

1. `JS` 中的对象使用时都是存在于计算机的内存中的
    - 序列化指将对象转换为一个可以存储的格式
    - 在 `JS` 中对象的序列化通常是将一个对象转换为字符串（`JSON` 字符串）

1. **序列化的用途**（对象转换为字符串有什么用）：
	- 对象转换为字符串后，可以将字符串在不同的语言之间进行传递
		甚至人可以直接对字符串进行读写操作，使得 `JS` 对象可以不同的语言之间传递
	- 用途：
		1. 作为数据交换的格式
		2. 用来编写配置文字

1. **如何进行序列化**：
	- 在JS中有一个工具类 JSON （JavaScript Object Notation） JS对象表示法
	- JS对象序列化后会转换为一个字符串，这个字符串我们称其为JSON字符串  
	- 也可以手动的编写JSON字符串，在很多程序的配置文件就是使用JSON编写的

1. **编写JSON的注意事项**：
	1. JSON字符串有两种类型：
		JSON对象 `{}`
		JSON数组 `[]`
	2. JSON字符串的属性名必须使用双引号引起来
	3. JSON中可以使用的属性值（元素）
		- 数字（Number）
		- 字符串（String） 必须使用双引号
		- 布尔值（Boolean）
		- 空值（Null）
		- 对象（Object {}）
		- 数组（Array []）
	4. JSON的格式和JS对象的格式基本上一致的，
		注意：JSON字符串如果属性是最后一个，则不要再加,

- 例子
	```js
	const obj = {
	    name: "孙悟空",
	    age: 18,
	}
	// 将obj转换为JSON字符串
	const str = JSON.stringify(obj) //JSON.stringify()可以将一个对象转换为JSON字符串
	const obj2 = JSON.parse(str) // JSON.parse() 可以将一个JSON格式的字符串转换为JS对象
	
	//JSON的编写
	const str2 = `{"name":"猪八戒","age":28}`//对象
	const str4 = '["hello", true, []]'//数组和二维数组
	```

#### 3.11.2.1 JSON 可以进行深复制

```js
const obj = {
    name: "孙悟空",
    friend: {
        name: "猪八戒",
    },    
    
    
}

// 对obj进行浅复制
const obj2 = Object.assign({}, obj)

// 对obj进行深复制
const obj3 = structuredClone(obj)

// 利用JSON来完成深复制
const str = JSON.stringify(obj)
const obj4 = JSON.parse(str)

const obj5 = JSON.parse(JSON.stringify(obj))
```


### 3.11.3 Map

#### 3.11.3.1 Map的基本概况

 - Map用来存储键值对结构的数据（key-value）
    - Object中存储的数据就可以认为是一种键值对结构
    - Map和Object的主要区别：
        - Object中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名，
            JS解释器会自动将其转换为字符串
        - Map中任何类型的值都可以称为数据的key

- 创建：
    - new Map()

- 属性和方法：
    - map.size() 获取map中键值对的数量
    - map.set(key, value) 向map中添加键值对
    - map.get(key) 根据key获取值   
    - map.delete(key) 删除指定数据
    - map.has(key) 检查map中是否包含指定键
    - map.clear() 删除全部的键值对

- 实例：
	```js
	//创建一个Map
	const map = new Map()
	//map.set(key, value) 向map中添加键值对
	map.set("name", "孙悟空")
	map.set(obj2, "呵呵")
	map.set(NaN, "哈哈哈")
	//map.get(key) 根据key获取值   
	console.log(map.get("name"))
	//map.has(key) 检查map中是否包含指定键
	console.log(map.has("name"))
	//map.delete(key) 删除指定数据
	map.delete(NaN)
	//删除全部的键值对
	map.clear()
	```

#### 3.11.3.2 Map和数组的转换

```js
const map = new Map()
map.set("name", "孙悟空") 
map.set("age", 18)
map.set({}, "呵呵")
// 将map转换为数组
const arr = Array.from(map) // [["name","孙悟空"],["age",18]]
const arr = [...map]//利用展开运算符
//将数组转换为Map
const map2 = new Map([
 ["name", "猪八戒"],
["age", 18],
[{}, () => {}],
])//直接将数组作为参数

// 遍历map
    //for循环
for (const [key, value] of map) {
     // const [key, value] = entry
    console.log(key, value)
 }
    //forEach
map.forEach((key, value)=>{
     console.log(key, value)
 })

//Map的方法
map.keys() //获取map的所有的key
map.values() // 获取map的所有的value
```

### 3.11.4 Set
- Set用来创建一个集合
- 它的功能和数组类似，不同点在于Set中不能存储重复的数据
> 
> - 使用方式：
>     - 创建
>         - new Set()
>         - new Set([...])
> 
> - 方法
> 	- size 获取数量
> 	- add() 添加元素
> 	- has() 检查元素
> 	- delete() 删除元素
```js
// 创建一个Set
const set = new Set()
// 向set中添加数据
set.add(10)
set.add("孙悟空")
set.add(10)
//set遍历
for(const item of set){
     console.log(item)
 }
 //转换成数组
 const arr = [...set]
```



### 3.11.5 Math
- Math一个工具类
- Math中为我们提供了数学运算相关的一些常量和方法
- 常量：
	- Math.PI 圆周率
- 方法：
	- Math.abs() 求一个数的绝对值
	- Math.min() 求多个值中的最小值
	- Math.max() 求多个值中的最大值
	- Math.pow() 求x的y次幂
	- Math.sqrt() 求一个数的平方根
	- 

	- Math.floor() 向下取整
	- Math.ceil() 向上取整
	- Math.round() 四舍五入取整
	- Math.trunc() 直接去除小数位
	- 

	- Math.random() 生成一个0-1之间的随机数

### 3.11.6 Date
- 在JS中所有的和时间相关的数据都由Date对象来表示
- 对象的方法：
	- getFullYear() 获取4位年份
	- getMonth() 返当前日期的月份（0-11）
	- getDate() 返回当前是几日
	- getDay() 返回当前日期是周几（0-6） 0表示周日
	- ......

	- getTime() 返回当前日期对象的时间戳
		- 时间戳：自1970年1月1日0时0分0秒到当前时间所经历的毫秒数
		- 计算机底层存储时间时，使用都是时间戳
	- Date.now() 获取当前的时间戳
	```js
	// 直接通过new Date()创建时间对象时，它创建的是当前的时间的对象
	let d = new Date()
	    // 可以在Date()的构造函数中，传递一个表示时间的字符串
	    // 字符串的格式：月/日/年 时:分:秒
	     // 年-月-日T时:分:秒
	    d = new Date("2019-12-23T23:34:35")
	    //// new Date(年份, 月, 日, 时, 分, 秒, 毫秒)
	    d = new Date(2016, 0, 1, 13, 45, 33)
	
	//
	d = new Date()
	result = d.getFullYear()//获取4位年份
	result = d.getMonth()//返当前日期的月份（0-11）
	result = d.getDate()//getDate() 返回当前是几日
	result = d.getDay()//getDay() 返回当前日期是周几（0-6） 0表示周日
	result = d.getTime()//返回当前日期对象的时间戳
	result = d.getNow()//获取当前的时间戳
	
	```

#### 3.11.6.1 日期的格式化
- toLocaleString()
    - 可以将一个日期转换为本地时间格式的字符串
    - 参数：
        - 描述语言和国家信息的字符串
            - zh-CN 中文中国
            - zh-HK 中文香港
            - en-US 英文美国
        - 需要一个对象作为参数，在对象中可以通过对象的属性来对日期的格式进行配置
		```js
		- dateStyle 日期的风格
		- timeStyle 时间的风格
			- full
			- long
			- medium
			- short
		- hour12 是否采用12小时值
			- true
			- false
		- weekday 星期的显示方式
			- long
			- short
			- narrow
		- year
			- numeric
			- 2-digit
		```

### 3.11.7 包装类
- 在JS中，除了直接创建原始值外，也可以创建原始值的对象
    - 通过 new String() 可以创建String类型的对象
    - 通过 new Number() 可以创建Number类型的对象
    - 通过 new Boolean() 可以创建Boolean类型的对象
        - 但是千万不要这么做

- 包装类：
    - JS中一共有5个包装类
        - String --> 字符串包装为String对象
        - Number --> 数值包装为Number对象
        - Boolean --> 布尔值包装为Boolean对象
        - BigInt --> 大整数包装为BigInt对象
        - Symbol --> 符号包装为Symbol对象
        - 通过包装类可以将一个原始值包装为一个对象，
            - 当我们对一个原始值调用方法或属性时，JS解释器会临时将原始值包装为对应的对象
                - 然后调用这个对象的属性或方法

    - 由于原始值会被临时转换为对应的对象，这就意味着对象中的方法都可以直接通过原始值来调用

### 3.11.8 字符串的方法

| 方法                             | 含义                             | 返回值                   |
| ------------------------------ | ------------------------------ | --------------------- |
| length                         | 获取字符串的长度,<br>字符串[索引] 获取指定位置的字符 |                       |
| str.at()（实验方法）                 | 根据索引获取字符，可以接受负索引               |                       |
| str.charAt()                   | 根据索引获取字符                       |                       |
| str.concat()                   | 用来连接两个或多个字符串                   |                       |
| str.includes()                 | 用来检查字符串中是否包含某个内容               | 有返回true,<br>没有返回false |
| str.indexOf()                  | 查询字符串中是否包含某个内容                 |                       |
| str.lastIndexOf()              | 查询字符串中是否包含某个内容                 |                       |
| str.startsWith()               | 查询字符串中是否包含某个内容                 |                       |
| str.endsWith()                 | 检查一个字符串是否以指定内容结尾               |                       |
| str.padStart()<br>str.padEnd() | 通过添加指定的内容，使字符串保持某个长度           |                       |
| str.replace()                  | 使用一个新字符串替换一个指定内容               |                       |
| str.replaceAll()               | 使用一个新字符串替换所有指定内容               |                       |
| str.slice()                    | 对字符串进行切片                       |                       |
| str.substring()                | 截取字符串                          |                       |
| str.split()                    | 用来将一个字符串拆分为一个数组                |                       |
| str.toLowerCase()              | 将字符串转换为小写                      |                       |
| str.toUpperCase()              | 将字符串转换为大写                      |                       |
| str.trim()                     | 去除前后空格                         |                       |
| str.trimStart()                | 去除开始空格                         |                       |
| str.trimEnd()                  | 去除结束空格                         |                       |

### 3.11.9 正则表达式

- 正则表达式用来定义一个规则
- 通过这个规则计算机可以检查一个字符串是否符合规则
	- 或者将字符串中符合规则的内容提取出来
- 正则表达式也是JS中的一个对象，
	- 所以要使用正则表达式，需要先创建正则表达式的对象

- 创建方式
    1. 通过构造函数创建
        - new RegExp() 可以接收两个参数（字符串） 
            1. 正则表达式 
            2. 匹配模式
    2. 使用字面量来创建正则表达式：/正则/匹配模式
        - reg = /a/i

- 实例：
	```js
	//通过构造函数创建
	let reg = new RegExp("a", "i")
	//使用字面量来创建正则表达式：/正则/匹配模式
	let reg = /a/i
	
	reg = new RegExp("a") // /a/ 表示，检查一个字符串中是否有a
	
	// 通过正则表达式检查一个字符串是否符合规则
	let str = "a"
	
	let result = reg.test(str) // true
	result = reg.test("b") // false
	result = reg.test("abc") // true
	result = reg.test("bcabc") // true
	```

### 3.11.10 正则表达式的语法
- 在正则表达式中大部分字符都可以直接写

| 符号        | 含义                     |
| --------- | ---------------------- |
| \|        | 在正则表达式中表示或             |
| []        | 表示或（字符集）               |
| [a-z]     | 任意的小写字母                |
| [A-Z]     | 任意的大写字母                |
| [a-zA-Z]  | 任意的字母                  |
| [0-9]     | 任意数字                   |
| [^]       | 表示除了                   |
| `[^x]`    | 除了x                    |
| `.`       | 表示除了换行外的任意字符           |
| \         | 在正则表达式中使用\作为转义字符       |
| \W        | 除了单词字符 `[^A-Za-z0-9_]` |
| \w        | 任意的单词字符 [A-Za-z0-9_]   |
| \D        | 除了数字 `[^0-9]`          |
| \s        | 空格                     |
| \S        | 除了空格                   |
| \b        | 单词边界                   |
| \B        | 除了单词边界                 |
| ^         | 表示字符串的开头               |
| $         | 表示字符串的结尾               |
| /^.... $/ | 完全匹配                   |
#### 3.11.10.1 正则表达式的量词

| 字符    | 含义           |
| ----- | ------------ |
| {m}   | 正好m个         |
| {m,}  | 至少m个         |
| {m,n} | m-n个         |
| +     | 一个以上，相当于{1,} |
| *     | 任意数量的a       |
| ?     | 0-1次 {0,1}   |
|       |              |


#### 3.11.10.2 正则表达式的方法

- re.exec()
     - 获取字符串中符合正则表达式的内容
- re.test()
    - 测试方法

- i表示忽略大小写    g表示全局匹配

- 实例：
	```js
	/* dajsdh13715678903jasdlakdkjg13457890657djashdjka13811678908sdadadasd */
	let re = /1[3-9]\d{9}/g
	let str = "dajsdh13715678903jasdlakdkjg13457890657djashdjka13811678908sdadadasd"
	let result
	while (result = re.exec(str)) {
	    // console.log(result[0], result[1], result[2])
	    console.log(result[1]+"****"+result[2])
	}
	//检查手机号是否合法
	let re = /^1[3-9]\d{9}$/
	console.log(re.test("13456789042"))
	```


### 3.11.11 垃圾回收（Garbage collection）
- 和生活一样，生活时间长了以后会产生生活垃圾
	- 程序运行一段时间后也会产生垃圾
- 在程序的世界中，什么是垃圾？
	- 如果一个对象没有任何的变量对其进行引用，那么这个对象就是一个垃圾
	- 垃圾对象的存在，会严重的影响程序的性能
	- 在JS中有自动的垃圾回收机制，这些垃圾对象会被解释器自动回收，我们无需手动处理
	- 对于垃圾回收来说，我们唯一能做的事情就是将不再使用的变量设置为null
